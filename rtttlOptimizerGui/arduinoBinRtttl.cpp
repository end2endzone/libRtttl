/**
 * This file was generated by
 * bin2cpp v1.3.
 * Copyright (C) 2013-2014 end2endzone.com. All rights reserved.
 * Do not modify this file.
 */
#include ".\arduinoBinRtttl.h"
#include <stdio.h> //for FILE
#include <string> //for memcpy
namespace bin2cpp
{
  class BinRtttlFile : public virtual bin2cpp::File
  {
  public:
    BinRtttlFile() {}
    ~BinRtttlFile() {}
    virtual size_t getSize() { return 4695; }
    virtual size_t getSegmentSize() { return 1000; }
    virtual size_t getNumSegments() { return 5; }
    virtual const char * getFilename() { return "arduino_binrtttl_library.template.ino"; }
    virtual const char * getSegment(size_t iIndex, size_t & oLength)
    {
      oLength = 0;
      if (iIndex >= getNumSegments())
        return NULL;
      const char * buffer = NULL;
      size_t index = 0;
      oLength = getSegmentSize();
      buffer = "// *************** RTTTL STRUCTURE DEFINITION START ***************\x0d\x0a\x0d\012typedef unsigned char DURATION_INDEX;\x0d\012typedef unsigned char NOTE_CHARACTER_INDEX;\x0d\012typedef unsigned char OCTAVE_INDEX;\x0d\012typedef unsigned short RTTTL_DURATION;\x0d\012typedef          char  RTTTL_NOTE_CHARACTER;\x0d\012typedef unsigned char  RTTTL_OCTAVE;\x0d\012typedef unsigned short RTTTL_BPM;\x0d\012typedef unsigned short TONE_DURATION;\x0d\012typedef unsigned short TONE_FREQUENCY;\x0d\x0a\x0d\012#define NOTE_SILENT 0\x0d\x0a\x0d\012#ifndef NOTE_B0\x0d\x0a\x0d\012#define NOTE_B0  31\x0d\012#define NOTE_C1  33\x0d\012#define NOTE_CS1 35\x0d\012#define NOTE_D1  37\x0d\012#define NOTE_DS1 39\x0d\012#define NOTE_E1  41\x0d\012#define NOTE_F1  44\x0d\012#define NOTE_FS1 46\x0d\012#define NOTE_G1  49\x0d\012#define NOTE_GS1 52\x0d\012#define NOTE_A1  55\x0d\012#define NOTE_AS1 58\x0d\012#define NOTE_B1  62\x0d\012#define NOTE_C2  65\x0d\012#define NOTE_CS2 69\x0d\012#define NOTE_D2  73\x0d\012#define NOTE_DS2 78\x0d\012#define NOTE_E2  82\x0d\012#define NOTE_F2  87\x0d\012#define NOTE_FS2 93\x0d\012#define NOTE_G2  98\x0d\012#define NOTE_GS2 104\x0d\012#define NOTE_A2  110\x0d\012#define NOTE_AS2 117\x0d\012#define NOTE_B2  "; if (iIndex == index) return buffer; index++;
      buffer = "123\x0d\012#define NOTE_C3  131\x0d\012#define NOTE_CS3 139\x0d\012#define NOTE_D3  147\x0d\012#define NOTE_DS3 156\x0d\012#define NOTE_E3  165\x0d\012#define NOTE_F3  175\x0d\012#define NOTE_FS3 185\x0d\012#define NOTE_G3  196\x0d\012#define NOTE_GS3 208\x0d\012#define NOTE_A3  220\x0d\012#define NOTE_AS3 233\x0d\012#define NOTE_B3  247\x0d\012#define NOTE_C4  262\x0d\012#define NOTE_CS4 277\x0d\012#define NOTE_D4  294\x0d\012#define NOTE_DS4 311\x0d\012#define NOTE_E4  330\x0d\012#define NOTE_F4  349\x0d\012#define NOTE_FS4 370\x0d\012#define NOTE_G4  392\x0d\012#define NOTE_GS4 415\x0d\012#define NOTE_A4  440\x0d\012#define NOTE_AS4 466\x0d\012#define NOTE_B4  494\x0d\012#define NOTE_C5  523\x0d\012#define NOTE_CS5 554\x0d\012#define NOTE_D5  587\x0d\012#define NOTE_DS5 622\x0d\012#define NOTE_E5  659\x0d\012#define NOTE_F5  698\x0d\012#define NOTE_FS5 740\x0d\012#define NOTE_G5  784\x0d\012#define NOTE_GS5 831\x0d\012#define NOTE_A5  880\x0d\012#define NOTE_AS5 932\x0d\012#define NOTE_B5  988\x0d\012#define NOTE_C6  1047\x0d\012#define NOTE_CS6 1109\x0d\012#define NOTE_D6  1175\x0d\012#define NOTE_DS6 1245\x0d\012#define NOTE_E6  1319\x0d\012#define NOTE_F6  1397\x0d\012#define NOTE_FS6 1480\x0d\012#define NOTE_G6  1568\x0d\012#define NOTE_GS6 16"; if (iIndex == index) return buffer; index++;
      buffer = "61\x0d\012#define NOTE_A6  1760\x0d\012#define NOTE_AS6 1865\x0d\012#define NOTE_B6  1976\x0d\012#define NOTE_C7  2093\x0d\012#define NOTE_CS7 2217\x0d\012#define NOTE_D7  2349\x0d\012#define NOTE_DS7 2489\x0d\012#define NOTE_E7  2637\x0d\012#define NOTE_F7  2794\x0d\012#define NOTE_FS7 2960\x0d\012#define NOTE_G7  3136\x0d\012#define NOTE_GS7 3322\x0d\012#define NOTE_A7  3520\x0d\012#define NOTE_AS7 3729\x0d\012#define NOTE_B7  3951\x0d\012#define NOTE_C8  4186\x0d\012#define NOTE_CS8 4435\x0d\012#define NOTE_D8  4699\x0d\012#define NOTE_DS8 4978\x0d\x0a\x0d\012#endif //NOTE_B0\x0d\x0a\x0d\012const TONE_FREQUENCY rtttlNotes[] = { NOTE_SILENT,\x0d\012NOTE_C4, NOTE_CS4, NOTE_D4, NOTE_DS4, NOTE_E4, NOTE_F4, NOTE_FS4, NOTE_G4, NOTE_GS4, NOTE_A4, NOTE_AS4, NOTE_B4,\x0d\012NOTE_C5, NOTE_CS5, NOTE_D5, NOTE_DS5, NOTE_E5, NOTE_F5, NOTE_FS5, NOTE_G5, NOTE_GS5, NOTE_A5, NOTE_AS5, NOTE_B5,\x0d\012NOTE_C6, NOTE_CS6, NOTE_D6, NOTE_DS6, NOTE_E6, NOTE_F6, NOTE_FS6, NOTE_G6, NOTE_GS6, NOTE_A6, NOTE_AS6, NOTE_B6,\x0d\012NOTE_C7, NOTE_CS7, NOTE_D7, NOTE_DS7, NOTE_E7, NOTE_F7, NOTE_FS7, NOTE_G7, NOTE_GS7, NOTE_A7, NOTE_AS7, NOTE_B7\x0d\012};\x0d\x0a\x0d\012#pragma pack(push, 1) //"; if (iIndex == index) return buffer; index++;
      buffer = " exact fit - no padding\x0d\012union RTTTL_NOTE\x0d\012{\x0d\012  unsigned short raw;\x0d\012  struct\x0d\012  {\x0d\012    DURATION_INDEX durationIdx    : 3; //ranges from 0 to 7. Matches index of durationValues[]\x0d\012    NOTE_CHARACTER_INDEX noteIdx  : 3; //ranges from 0 to 7. Matches index of noteCharacterCodes[]\x0d\012    bool pound                    : 1; //ranges from 0 to 1. True if the note is pound\x0d\012    bool dotted                   : 1; //ranges from 0 to 1. True if the duration is dotted\x0d\012    OCTAVE_INDEX octaveIdx        : 2; //ranges from 0 to 3. Matches index of octaveValues[]\x0d\012    unsigned char padding         : 6;\x0d\012  };\x0d\012};\x0d\x0a\x0d\012union RTTTL_DEFAULT_VALUE_SECTION\x0d\012{\x0d\012  unsigned short raw;\x0d\012  //struct \x0d\012  //{\x0d\012  //  DURATION_INDEX durationIdx :  3; //ranges from 0 to 7.  Matches index of durationValues[]\x0d\012  //  OCTAVE_INDEX octaveIdx     :  2; //ranges from 0 to 3.  Matches index of octaveValues[]\x0d\012  //  RTTTL_BPM              bpm : 10; //ranges from 1 to 900.\x0d\012  //};\x0d\012  struct //aligned on 8 bits types\x0d\012  {\x0d\012    DUR"; if (iIndex == index) return buffer; index++;
      oLength = 695;
      buffer = "ATION_INDEX durationIdx :  3; //ranges from 0 to 7.  Matches index of durationValues[]\x0d\012    OCTAVE_INDEX     octaveIdx :  2; //ranges from 0 to 3.  Matches index of octaveValues[]\x0d\012  };\x0d\012  struct //aligned on 16 bits types\x0d\012  {\x0d\012    unsigned short        :  5; //padding for durationIdx and octaveIdx\x0d\012    RTTTL_BPM         bpm : 10; //ranges from 1 to 900.\x0d\012  };\x0d\012};\x0d\012#pragma pack(pop) //back to whatever the previous packing mode was\x0d\x0a\x0d\012// *************** RTTTL STRUCTURE DEFINITION END ***************\x0d\x0a\x0d\012const unsigned char noteCharacterCodes[] = { 1, 3, 5, 6, 8, 10, 12, 0};\x0d\012const RTTTL_DURATION durationValues[] = {1, 2, 4, 8, 16, 32};\x0d\012const RTTTL_OCTAVE octaveValues[] = {4, 5, 6, 7};\x0d\x0a"; if (iIndex == index) return buffer; index++;
      oLength = 0;
      return NULL;
    }
    virtual const char * getMd5() { return "2e5f7ac37373374303ebcd55b3073d27"; }
    virtual char * newBuffer()
    {
      size_t size = getSize();
      char * buffer = new char[size];
      if (buffer == NULL)
        return NULL;
      size_t numSegments = getNumSegments();
      size_t segmentLength = 0;
      size_t index = 0;
      for(size_t i=0; i<numSegments; i++)
      {
        const char * segmentBuffer = getSegment(i, segmentLength);
        memcpy(&buffer[index], segmentBuffer, segmentLength);
        index += segmentLength;
      }
      return buffer;
    }
    virtual bool save(const char * iFilename)
    {
      FILE * f = fopen(iFilename, "wb");
      if (!f) return false;
      size_t numSegments = getNumSegments();
      size_t segmentLength = 0;
      const char * buffer = NULL;
      for(size_t i=0; i<numSegments; i++)
      {
        buffer = getSegment(i, segmentLength);
        fwrite(buffer, 1, segmentLength, f);
      }
      fclose(f);
      return true;
    }
  };
  File & getBinRtttlFile() { static BinRtttlFile _instance; return _instance; }
}; //bin2cpp
