/**
 * This file was generated by
 * bin2cpp v1.3.
 * Copyright (C) 2013-2014 end2endzone.com. All rights reserved.
 * Do not modify this file.
 */
#include ".\arduinoPlay10BitsRtttl.h"
#include <stdio.h> //for FILE
#include <string> //for memcpy
namespace bin2cpp
{
  class Play10BitsRtttlFile : public virtual bin2cpp::File
  {
  public:
    Play10BitsRtttlFile() {}
    ~Play10BitsRtttlFile() {}
    virtual size_t getSize() { return 2553; }
    virtual size_t getSegmentSize() { return 1000; }
    virtual size_t getNumSegments() { return 3; }
    virtual const char * getFilename() { return "arduino_play10bitsRtttl.template.ino"; }
    virtual const char * getSegment(size_t iIndex, size_t & oLength)
    {
      oLength = 0;
      if (iIndex >= getNumSegments())
        return NULL;
      const char * buffer = NULL;
      size_t index = 0;
      oLength = getSegmentSize();
      buffer = "void play10BitsRtttl(int pin, const unsigned char * iBuffer, int numNotes) {\x0d\012  // Absolutely no error checking in here\x0d\x0a\x0d\012  RTTTL_DEFAULT_VALUE_SECTION * defaultSection = (RTTTL_DEFAULT_VALUE_SECTION *)iBuffer;\x0d\012  RTTTL_NOTE * notesBuffer = (RTTTL_NOTE *)&iBuffer[2];\x0d\x0a\x0d\012  #ifndef USE_BITADDRESS_READ_WRITE\x0d\012  BitReader bitreader;\x0d\012  #else\x0d\012  BitAddress bitreader;\x0d\012  #endif\x0d\012  \x0d\012  bitreader.setBuffer(notesBuffer);\x0d\x0a\x0d\012  RTTTL_BPM bpm = defaultSection->bpm;\x0d\x0a\x0d\012  #ifdef RTTTL_SERIAL_DEBUG\x0d\012  Serial.print(\"numNotes=\");\x0d\012  Serial.println(numNotes);\x0d\012  // format: d=N,o=N,b=NNN:\x0d\012  Serial.print(\"d=\");\x0d\012  Serial.print(durationValues[defaultSection->durationIdx]);\x0d\012  Serial.print(\",o=\");\x0d\012  Serial.print(octaveValues[defaultSection->octaveIdx]);\x0d\012  Serial.print(\",b=\");\x0d\012  Serial.println(bpm);\x0d\012  #endif\x0d\012  \x0d\012  TONE_DURATION duration;\x0d\012  byte note;\x0d\012  RTTTL_OCTAVE scale;\x0d\x0a\x0d\012  // BPM usually expresses the number of quarter notes per minute\x0d\012  TONE_DURATION wholenote = (60 * 1000L / bpm) * 4;  // thi"; if (iIndex == index) return buffer; index++;
      buffer = "s is the time for whole note (in milliseconds)\x0d\x0a\x0d\012  // now begin note loop\x0d\012  for(int i=0; i<numNotes; i++) {\x0d\012    RTTTL_NOTE n;\x0d\012    n.raw = 0;\x0d\012    bitreader.read(10, &n.raw);\x0d\x0a\x0d\012    // first, get note duration, if available\x0d\012    duration = wholenote / durationValues[n.durationIdx];\x0d\x0a\x0d\012    // now get the note\x0d\012    note = noteCharacterCodes[n.noteIdx];\x0d\x0a\x0d\012    // now, get optional '#' sharp\x0d\012    if(n.pound)\x0d\012    {\x0d\012      note++;\x0d\012    }\x0d\x0a\x0d\012    // now, get optional '.' dotted note\x0d\012    if(n.dotted)\x0d\012    {\x0d\012      duration += duration/2;\x0d\012    }\x0d\x0a\x0d\012    // now, get scale\x0d\012    scale = octaveValues[n.octaveIdx];\x0d\x0a\x0d\012    if(note)\x0d\012    {\x0d\012      #ifdef RTTTL_SERIAL_DEBUG\x0d\012      Serial.print(durationValues[n.durationIdx]);\x0d\012      static const char noteCharacterValues[] =   {'c','d','e','f','g','a','b','p'};\x0d\012      Serial.print(noteCharacterValues[n.noteIdx]);\x0d\012      Serial.print( (n.pound ? \"#\" : \"\") );\x0d\012      Serial.print( (n.dotted ? \".\" : \"\") );\x0d\012      Serial.println(octaveValues[n.octaveIdx]);\x0d"; if (iIndex == index) return buffer; index++;
      oLength = 553;
      buffer = "\012      #endif\x0d\012      \x0d\012      tone(pin, rtttlNotes[(scale - 4) * 12 + note], duration);\x0d\012      delay(duration+1);\x0d\012      noTone(pin);\x0d\012    }\x0d\012    else\x0d\012    {\x0d\012      #ifdef RTTTL_SERIAL_DEBUG\x0d\012      Serial.print(durationValues[n.durationIdx]);\x0d\012      static const char noteCharacterValues[] =   {'c','d','e','f','g','a','b','p'};\x0d\012      Serial.print(noteCharacterValues[n.noteIdx]);\x0d\012      Serial.print( (n.pound ? \"#\" : \"\") );\x0d\012      Serial.print( (n.dotted ? \".\" : \"\") );\x0d\012      Serial.println();\x0d\012      #endif\x0d\x0a\x0d\012      delay(duration);\x0d\012    }\x0d\012  }\x0d\012}\x0d\x0a"; if (iIndex == index) return buffer; index++;
      oLength = 0;
      return NULL;
    }
    virtual const char * getMd5() { return "e55b5456f110edd85dc7129b83ea1c79"; }
    virtual char * newBuffer()
    {
      size_t size = getSize();
      char * buffer = new char[size];
      if (buffer == NULL)
        return NULL;
      size_t numSegments = getNumSegments();
      size_t segmentLength = 0;
      size_t index = 0;
      for(size_t i=0; i<numSegments; i++)
      {
        const char * segmentBuffer = getSegment(i, segmentLength);
        memcpy(&buffer[index], segmentBuffer, segmentLength);
        index += segmentLength;
      }
      return buffer;
    }
    virtual bool save(const char * iFilename)
    {
      FILE * f = fopen(iFilename, "wb");
      if (!f) return false;
      size_t numSegments = getNumSegments();
      size_t segmentLength = 0;
      const char * buffer = NULL;
      for(size_t i=0; i<numSegments; i++)
      {
        buffer = getSegment(i, segmentLength);
        fwrite(buffer, 1, segmentLength, f);
      }
      fclose(f);
      return true;
    }
  };
  File & getPlay10BitsRtttlFile() { static Play10BitsRtttlFile _instance; return _instance; }
}; //bin2cpp
